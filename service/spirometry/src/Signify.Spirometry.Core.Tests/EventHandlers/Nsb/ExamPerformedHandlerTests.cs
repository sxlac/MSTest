using AutoMapper;
using FakeItEasy;
using MediatR;
using Microsoft.Extensions.Logging;
using NsbEventHandlers;
using NServiceBus.Testing;
using NServiceBus;
using Signify.AkkaStreams.Kafka.Persistence;
using Signify.Dps.Observability.Library.Events;
using Signify.Dps.Observability.Library.Services;
using Signify.Spirometry.Core.Commands;
using Signify.Spirometry.Core.Configs.Loopback;
using Signify.Spirometry.Core.Data.Entities;
using Signify.Spirometry.Core.Data;
using Signify.Spirometry.Core.Events.Akka;
using Signify.Spirometry.Core.Models;
using Signify.Spirometry.Core.Queries;
using Signify.Spirometry.Core.Services;
using SpiroNsbEvents;
using System.Threading.Tasks;
using System.Threading;
using System;
using Xunit;

using StatusCode = Signify.Spirometry.Core.Models.StatusCode;
using ExamStatusEvent = Signify.Spirometry.Core.Events.ExamStatusEvent;

namespace Signify.Spirometry.Core.Tests.EventHandlers.Nsb;

public sealed class ExamPerformedHandlerTests
{
    private readonly IGetLoopbackConfig _loopbackConfig = A.Fake<IGetLoopbackConfig>();
    private readonly IMediator _mediator = A.Fake<IMediator>();
    private readonly IMapper _mapper = A.Fake<IMapper>();
    private readonly ITransactionSupplier _transactionSupplier = A.Fake<ITransactionSupplier>();
    private readonly IExamQualityService _examQualityService = A.Fake<IExamQualityService>();
    private readonly IPublishObservability _publishObservability = A.Fake<IPublishObservability>();
    
    private ExamPerformedHandler CreateSubject()
    {
        return new ExamPerformedHandler(A.Dummy<ILogger<ExamPerformedHandler>>(),
            _loopbackConfig,
            _mediator,
            _mapper,
            _transactionSupplier,
            _examQualityService,
            _publishObservability);
    }

    [Fact]
    public async Task Handle_WithMessage_AddsExamAndResults()
    {
        // Arrange
        const int evaluationId = 1;
        const int spirometryExamId = 2;

        var request = new ExamPerformedEvent
        {
            Exam = new SpirometryExam
            {
                // No SpirometryExamId passed into the event; this will be generated by AddExam command
                EvaluationId = evaluationId
            },
            Result = new RawExamResult()
        };

        var addExamResult = new SpirometryExam
        {
            SpirometryExamId = spirometryExamId,
            EvaluationId = evaluationId
        };

        var validatedResult = new ExamResult();

        A.CallTo(() => _mapper.Map<ExamResult>(A<RawExamResult>.That.Equals(request.Result)))
            .Returns(validatedResult);

        A.CallTo(() => _mediator.Send(A<AddExam>._, A<CancellationToken>._))
            .Returns(addExamResult);

        var transaction = A.Fake<IBufferedTransaction>();
        A.CallTo(() => _transactionSupplier.BeginTransaction())
            .Returns(transaction);

        // Act
        var subject = CreateSubject();

        await subject.Handle(request, A.Dummy<IMessageHandlerContext>());

        // Assert
        A.CallTo(() => _mediator.Send(A<AddExam>.That.Matches(
                cmd => cmd.Exam == request.Exam), A<CancellationToken>._))
            .MustHaveHappenedOnceExactly();
        A.CallTo(() => _mediator.Send(A<AddExamResults>.That.Matches(
                cmd => cmd.SpirometryExamId == spirometryExamId && cmd.ExamResult == validatedResult), A<CancellationToken>._))
            .MustHaveHappenedOnceExactly();

        A.CallTo(() => _transactionSupplier.BeginTransaction())
            .MustHaveHappened();
        A.CallTo(() => transaction.CommitAsync(A<CancellationToken>._))
            .MustHaveHappened();
        A.CallTo(() => transaction.Dispose())
            .MustHaveHappened();
        
        A.CallTo(() => _publishObservability.RegisterEvent(A<ObservabilityEvent>._, true)).MustHaveHappenedOnceExactly();
    }

    [Theory]
    [InlineData(false, false, true)]
    [InlineData(false, true, true)]
    [InlineData(true, false, true)]
    [InlineData(true, true, false)]
    public async Task Handle_WithMessage_PublishesResultsTests(
        bool shouldProcessOverreads, bool needsOverread,
        bool expectedToPublish)
    {
        // Arrange
        const int evaluationId = 1;

        var request = new ExamPerformedEvent
        {
            EventId = Guid.NewGuid(),
            Exam = new SpirometryExam
            {
                // No SpirometryExamId passed into the event; this will be generated by AddExam command
                EvaluationId = evaluationId
            },
            Result = new RawExamResult()
        };

        var validatedResult = new ExamResult();

        A.CallTo(() => _loopbackConfig.ShouldProcessOverreads)
            .Returns(shouldProcessOverreads);
        A.CallTo(() => _loopbackConfig.IsVersionEnabled(A<int?>._))
            .Returns(shouldProcessOverreads);
        A.CallTo(() => _examQualityService.NeedsOverread(A<SpirometryExamResult>._))
            .Returns(needsOverread);
        A.CallTo(() => _mapper.Map<ExamResult>(A<RawExamResult>._))
            .Returns(validatedResult);

        var resultsToPublish = new ResultsReceived();

        A.CallTo(() => _mapper.Map<ResultsReceived>(A<SpirometryExamResult>._))
            .Returns(resultsToPublish);

        var spirometryExamResult = new SpirometryExamResult();

        A.CallTo(() => _mediator.Send(A<AddExamResults>._, A<CancellationToken>._))
            .Returns(spirometryExamResult);

        // Act
        var subject = CreateSubject();

        await subject.Handle(request, A.Dummy<IMessageHandlerContext>());

        // Assert
        A.CallTo(() => _mapper.Map<ExamResult>(
                A<RawExamResult>.That.Matches(r => r == request.Result)))
            .MustHaveHappened();

        if (expectedToPublish)
        {
            A.CallTo(() => _mapper.Map(
                    A<SpirometryExam>.That.Matches(r => r == request.Exam),
                    A<ResultsReceived>.That.Matches(r => r == resultsToPublish)))
                .MustHaveHappened();
            A.CallTo(() => _mapper.Map<ResultsReceived>(
                    A<SpirometryExamResult>.That.Matches(r => r == spirometryExamResult)))
                .MustHaveHappened();
            A.CallTo(() => _mediator.Send(A<PublishResults>.That.Matches(
                        cmd => cmd.EventId == request.EventId && cmd.Event == resultsToPublish),
                    A<CancellationToken>._))
                .MustHaveHappened();
            A.CallTo(() => _mediator.Send(A<ExamStatusEvent>.That.Matches(e =>
                        e.StatusCode == StatusCode.ResultsReceived),
                    A<CancellationToken>._))
                .MustHaveHappened();
            
            A.CallTo(() => _publishObservability.RegisterEvent(A<ObservabilityEvent>._, true)).MustHaveHappenedOnceExactly();
        }
        else
        {
            A.CallTo(() => _mapper.Map(A<SpirometryExam>._, A<ResultsReceived>._))
                .MustNotHaveHappened();
            A.CallTo(() => _mapper.Map<ResultsReceived>(A<ExamResult>._))
                .MustNotHaveHappened();
            A.CallTo(() => _mediator.Send(A<PublishResults>._, A<CancellationToken>._))
                .MustNotHaveHappened();
            A.CallTo(() => _mediator.Send(A<ExamStatusEvent>.That.Matches(e =>
                        e.StatusCode == StatusCode.ResultsReceived),
                    A<CancellationToken>._))
                .MustNotHaveHappened();
        }
    }

    [Theory]
    // Pre-overreads
    [InlineData(false, false, false, false)]
    [InlineData(false, false, true, true)]
    //
    [InlineData(false, true, false, false)]
    [InlineData(false, true, true, true)]
    [InlineData(true, false, false, false)]
    [InlineData(true, false, true, true)]
    [InlineData(true, true, false,
        null)] // Cannot determine IsBillable until overread processed; doesn't matter that pre-overread POC results are not billable
    [InlineData(true, true, true, null)] // Cannot determine IsBillable until overread processed; doesn't matter that pre-overread POC results are billable
    public async Task Handle_WithMessage_SetsIsBillable_InPublishedResults(
        bool shouldProcessOverreads, bool needsOverread, bool isBillablePoc,
        bool? expectedIsBillable)
    {
        // Arrange
        const int evaluationId = 1;

        var request = new ExamPerformedEvent
        {
            EventId = Guid.NewGuid(),
            Exam = new SpirometryExam
            {
                // No SpirometryExamId passed into the event; this will be generated by AddExam command
                EvaluationId = evaluationId
            },
            Result = new RawExamResult()
        };

        var validatedResult = new ExamResult();

        A.CallTo(() => _loopbackConfig.ShouldProcessOverreads)
            .Returns(shouldProcessOverreads);
        A.CallTo(() => _loopbackConfig.IsVersionEnabled(A<int?>._))
            .Returns(shouldProcessOverreads);
        A.CallTo(() => _examQualityService.NeedsOverread(A<SpirometryExamResult>._))
            .Returns(needsOverread);
        A.CallTo(() => _mapper.Map<ExamResult>(A<RawExamResult>._))
            .Returns(validatedResult);

        var resultsToPublish = new ResultsReceived();

        A.CallTo(() => _mapper.Map<ResultsReceived>(A<ExamResult>._))
            .Returns(resultsToPublish);

        var spirometryExamResult = new SpirometryExamResult();

        A.CallTo(() => _mediator.Send(A<AddExamResults>._, A<CancellationToken>._))
            .Returns(spirometryExamResult);

        A.CallTo(() => _mediator.Send(A<QueryBillability>._, A<CancellationToken>._))
            .Returns(new QueryBillabilityResult(isBillablePoc));

        // Act
        var subject = CreateSubject();

        await subject.Handle(request, A.Dummy<IMessageHandlerContext>());

        // Assert
        if (!shouldProcessOverreads || !needsOverread)
        {
            A.CallTo(() => _mediator.Send(A<QueryBillability>.That.Matches(q =>
                    q.EventId == request.EventId &&
                    q.EvaluationId == request.Exam.EvaluationId &&
                    q.ExamResult == spirometryExamResult), A<CancellationToken>._))
                .MustHaveHappened();
            A.CallTo(() => _mediator.Send(A<PublishResults>.That.Matches(p => p.Event.IsBillable == expectedIsBillable), A<CancellationToken>._))
                .MustHaveHappened();
        }
        else // If we should process overreads and one is needed, we don't know the results until it's processed, so should not publish
        {
            A.CallTo(() => _mediator.Send(A<QueryBillability>._, A<CancellationToken>._))
                .MustNotHaveHappened();
            A.CallTo(() => _mediator.Send(A<PublishResults>._, A<CancellationToken>._))
                .MustNotHaveHappened();
        }
    }

    [Fact]
    public async Task Handle_WithMessage_SendsExamPerformedStatus()
    {
        const int evaluationId = 1;
        const int spirometryExamId = 2;

        var request = new ExamPerformedEvent
        {
            Exam = new SpirometryExam
            {
                // No SpirometryExamId passed into the event; this will be generated by AddExam command
                EvaluationId = evaluationId,
                EvaluationReceivedDateTime = DateTime.UtcNow
            },
            Result = new RawExamResult(),
            EventId = Guid.NewGuid()
        };

        var addExamResult = new SpirometryExam
        {
            SpirometryExamId = spirometryExamId,
            EvaluationId = evaluationId,
            EvaluationReceivedDateTime = request.Exam.EvaluationReceivedDateTime
        };

        var validatedResult = new ExamResult();

        A.CallTo(() => _mapper.Map<ExamResult>(A<RawExamResult>.That.Equals(request.Result)))
            .Returns(validatedResult);

        A.CallTo(() => _mediator.Send(A<AddExam>._, A<CancellationToken>._))
            .Returns(addExamResult);

        await CreateSubject().Handle(request, new TestableMessageHandlerContext());

        A.CallTo(() => _mediator.Send(A<ExamStatusEvent>.That.Matches(s =>
                    s.StatusCode == StatusCode.SpirometryExamPerformed &&
                    s.EventId == request.EventId &&
                    s.Exam == addExamResult &&
                    s.StatusDateTime == request.Exam.EvaluationReceivedDateTime),
                A<CancellationToken>._))
            .MustHaveHappened();
    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public async Task Handle_IsFormVersionEnabled_Tests(bool isProviderEnabled)
    {
        // Arrange
        const int formVersionId = 1;

        var request = new ExamPerformedEvent
        {
            Exam = new SpirometryExam
            {
                // No SpirometryExamId passed into the event; this will be generated by AddExam command
                FormVersionId = formVersionId
            }
        };

        A.CallTo(() => _mediator.Send(A<AddExam>._, A<CancellationToken>._))
            .Returns(request.Exam);

        A.CallTo(() => _loopbackConfig.IsVersionEnabled(A<int?>._))
            .Returns(isProviderEnabled);

        A.CallTo(() => _loopbackConfig.ShouldProcessOverreads)
            .Returns(true);
        A.CallTo(() => _examQualityService.NeedsOverread(A<SpirometryExamResult>._))
            .Returns(true);

        var context = new TestableMessageHandlerContext();

        // Act
        await CreateSubject().Handle(request, context);

        // Assert
        A.CallTo(() => _loopbackConfig.IsVersionEnabled(A<int?>.That.Matches(p => p == formVersionId)))
            .MustHaveHappened();

        if (isProviderEnabled)
        {
            A.CallTo(() => _mediator.Send(A<QueryBillability>._, A<CancellationToken>._))
                .MustNotHaveHappened();
        }
        else
        {
            A.CallTo(() => _mediator.Send(A<QueryBillability>._, A<CancellationToken>._))
                .MustHaveHappened();
        }

        A.CallTo(() => _mediator.Send(A<SendEvaluationProcessedEvent>.That.Matches(e =>
                e.EvaluationProcessedEvent.NeedsOverread == isProviderEnabled)
            , A<CancellationToken>._)).MustHaveHappenedOnceExactly();
    }
}