@dee
@envnot=prod
Feature: DEE ProviderPay - Canceled and Missing Evaluation Tests

    Background:
        * eval if (env == 'prod') karate.abort();
        * def DataGen = function() { var DataGen = Java.type("helpers.data.DataGen"); return new DataGen(); }
        * def DeeDb = function() { var DeeDb = Java.type("helpers.database.dee.DeeDb"); return new DeeDb(); }

        * def timestamp = DataGen().isoTimestamp()
        * def dateStamp = DataGen().isoDateStamp()
        * def cdiDateTime = DataGen().timestampWithOffset("-05:00", -1)
        * def monthDayYearCdi = DataGen().getMonthDayYear(cdiDateTime)

        * def memberDetails = karate.call("classpath:helpers/member/createMember.js")
        * def KafkaConsumerHelper = Java.type('helpers.kafka.KafkaConsumerHelper')
        * def KafkaProducerHelper = Java.type('helpers.kafka.KafkaProducerHelper')

    @TestCaseKey=ANC-T849
    Scenario: DEE ProviderPay - Evaluation is Canceled without Finalizing. Id - <rowId>
        # Setting product code other than DEE so that the evaluation is created but the cdi events generated by cdi does not have DEE. This will lead to 'exam not found' scenario.
        * def appointment = karate.call('classpath:helpers/appointment/createAppointment.feature', { products: ['HHRA', 'PAD'] }).response
        * def evaluation = karate.call("classpath:helpers/eval/startEval.feature").response
        * def image1 = karate.readAsString('classpath:ancillary_services/features/dee/images/normalEval/image-1.txt')
        * def image2 = karate.readAsString('classpath:ancillary_services/features/dee/images/normalEval/image-2.txt')
        * set evaluation.answers =
            """
            [
                {
                    "AnswerId": 29554,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "1"
                },
                {
                    "AnswerId": 28377,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "John"
                },
                {
                    "AnswerId": 28378,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "Doe"
                },
                {
                    "AnswerId": 30974,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "M"
                },
                {
                    "AnswerId": 28383,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "TX"
                },
                {
                    "AnswerId": 30856,
                    "AnswerRowId": "6DBB912A-A078-4E7B-BE03-9DDB182628E4",
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(image1)"
                },
                {
                    "AnswerId": 30856,
                    "AnswerRowId": "FDBEC026-C6BE-4E5E-BE80-D6AC93E61F78",
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(image2)"
                },
                {
                    "AnswerId": 22034,
                    "AnsweredDateTime": "#(dateStamp)",
                    "AnswerValue": "#(dateStamp)"
                },
                {
                    "AnswerId": 33445,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(timestamp)"
                },
                {
                    "AnswerId": 21989,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.signature)"
                },
                {
                    "AnswerId": 28386,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.firstName) #(providerDetails.lastName)"
                },
                {
                    "AnswerId": 28387,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.nationalProviderIdentifier)"
                },
                {
                    "AnswerId": 22019,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.degree)"
                }
            ]
            """

        * karate.call("classpath:helpers/eval/saveEval.feature")
        * karate.call("classpath:helpers/eval/stopEval.feature")
        * karate.call("classpath:helpers/eval/cancelEval.feature")
       
        # Validate that no entry was made into the DEE table
        * def evalResult = DeeDb().getExamId(evaluation.evaluationId, 3, 500)[0]
        * match evalResult == "#null"
        
        # Publish the cdi event to the cdi_events topic as the events raised by cdi service have PAD instead of DEE
        * string cdiEventName = "cdi_events"
        * string cdiEventKey = evaluation.evaluationId + "_" + monthDayYearCdi
        * def eventId = DataGen().uuid()
        * string cdiEventHeader = { 'Type' : "CDIPassedEvent"}
         # Including DEE in product code so that PM processes the event as the one published by cdi has PAD instead of DEE
        * def cdiEventValue = 
        """
            {
                "RequestId":"#(eventId)",
                "EvaluationId": "#(evaluation.evaluationId)",
                "DateTime":"#(cdiDateTime)",
                "Username":"karateTestUser",
                "ApplicationId":"manual",
                "Reason":"reschedule",
                "Products":[
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"HHRA"
                    },
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"DEE"
                    }
                ]
            }
        """
        * string cdiEventValueStr = cdiEventValue
        * KafkaProducerHelper.send(cdiEventName, cdiEventKey, cdiEventHeader, cdiEventValueStr)
        
        # Validate that there is no entry in the ProviderPay table
        * def providerPay = DeeDb().getProviderPayResultsWithEvalId(evaluation.evaluationId)[0]
        * match providerPay == "#null"

        # Validate that the Kafka event - ProviderPayRequestSent - was not raised
        * json event = JSON.parse(KafkaConsumerHelper.getMessageByTopicAndKeyAndHeader("dee_status", evaluation.evaluationId + '', "ProviderPayRequestSent", 10, 5000))
        * match event == {} 
        
        # Validate that the Kafka event - ProviderPayableEventReceived - was not raised
        * json payableEvent = JSON.parse(KafkaConsumerHelper.getKafkaMessageByTopicAndKeyAndHeader("dee_status", evaluation.evaluationId + '', "ProviderPayableEventReceived", 10, 5000))   
        * match payableEvent == {} 
        ## Additional checks on error queue count increasing to be added
        ## Additional checks on New Relic dashboard updates to be added


    # The test sends an EvaluationFinalizedEvent after sending EvaluationCanceledEvent with DEE product code thus creating a converted evaluation scenario
    @TestCaseKey=ANC-T848
    Scenario: DEE ProviderPay - Converted Evaluations - Evaluation is Finalized after Canceling. Id - <rowId>
        * def appointment = karate.call('classpath:helpers/appointment/createAppointment.feature', { products: ['HHRA', 'DEE'] }).response
        * def evaluation = karate.call("classpath:helpers/eval/startEval.feature").response
        * def image1 = karate.readAsString('classpath:ancillary_services/features/dee/images/normalEval/image-1.txt')
        * def image2 = karate.readAsString('classpath:ancillary_services/features/dee/images/normalEval/image-2.txt')
        * set evaluation.answers =
            """
            [
                {
                    "AnswerId": 29554,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "1"
                },
                {
                    "AnswerId": 28377,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "John"
                },
                {
                    "AnswerId": 28378,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "Doe"
                },
                {
                    "AnswerId": 30974,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "M"
                },
                {
                    "AnswerId": 28383,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "TX"
                },
                {
                    "AnswerId": 30856,
                    "AnswerRowId": "6DBB912A-A078-4E7B-BE03-9DDB182628E4",
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(image1)"
                },
                {
                    "AnswerId": 30856,
                    "AnswerRowId": "FDBEC026-C6BE-4E5E-BE80-D6AC93E61F78",
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(image2)"
                },
                {
                    "AnswerId": 22034,
                    "AnsweredDateTime": "#(dateStamp)",
                    "AnswerValue": "#(dateStamp)"
                },
                {
                    "AnswerId": 33445,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(timestamp)"
                },
                {
                    "AnswerId": 21989,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.signature)"
                },
                {
                    "AnswerId": 28386,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.firstName) #(providerDetails.lastName)"
                },
                {
                    "AnswerId": 28387,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.nationalProviderIdentifier)"
                },
                {
                    "AnswerId": 22019,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.degree)"
                }
            ]
            """

        * karate.call("classpath:helpers/eval/saveEval.feature")
        * karate.call("classpath:helpers/eval/stopEval.feature")
        * karate.call("classpath:helpers/eval/cancelEval.feature")        
        
        # Publish the cdi event to the cdi_events topic
        * string cdiEventName = "cdi_events"
        * string cdiEventKey = evaluation.evaluationId + "_" + monthDayYearCdi
        * def eventId = DataGen().uuid()
        * string cdiEventHeader = { 'Type' : "CDIFailedEvent"}
        # Including DEE in product code so that PM processes the event. Explicitly publishing the event as the one published by cdi does not have DEE Product Code
        * def cdiEventValue = 
        """
            {
                "RequestId":"#(eventId)",
                "EvaluationId": "#(evaluation.evaluationId)",
                "DateTime":"#(cdiDateTime)",
                "Username":"karateTestUser",
                "ApplicationId":"manual",
                "Reason":"reschedule",
                "PayProvider": false,
                "Products":[
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"HHRA"
                    },
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"DEE"
                    }
                ]
            }
        """
        * string cdiEventValueStr = cdiEventValue
        * KafkaProducerHelper.send(cdiEventName, cdiEventKey, cdiEventHeader, cdiEventValueStr)
        
        * karate.call("classpath:helpers/eval/finalizeEval.feature")
        * def sleep = function(pause){ java.lang.Thread.sleep(pause) }
        * sleep(5000)

        # Validate that an entry was made into the DEE table since Eval is finalized
        * def evalResult = DeeDb().getExamId(evaluation.evaluationId,15,3000)[0]
        * match evalResult == "#notnull"
        
        # Publish the cdi event to the cdi_events topic 
        * def eventId = DataGen().uuid()
        * string cdiEventHeader = { 'Type' : "CDIPassedEvent"}
        # Including DEE in product code so that PM processes the event.
        * def cdiEventValue = 
        """
            {
                "RequestId":"#(eventId)",
                "EvaluationId": "#(evaluation.evaluationId)",
                "DateTime":"#(cdiDateTime)",
                "Username":"karateTestUser",
                "ApplicationId":"manual",
                "Reason":"reschedule",
                "Products":[
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"HHRA"
                    },
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"DEE"
                    }
                ]
            }
        """
        * string cdiEventValueStr = cdiEventValue
        * KafkaProducerHelper.send(cdiEventName, cdiEventKey, cdiEventHeader, cdiEventValueStr)

        # Validate Database response contains 26 - CdiPassedReceived
        * def result = DeeDb().queryExamWithStatusList(evaluation.evaluationId,["CdiPassedReceived"])
        * match result[*].ExamStatusCodeId contains 26

        ## Additional checks on error queue count increasing to be added
        ## Additional checks on New Relic dashboard updates to be added
    
    # The test sends a EvaluationFinalizedEvent without DEE product code thus creating a missing evaluation scenario
    @TestCaseKey=ANC-T850
    Scenario: DEE ProviderPay - Missing Evaluations - Evaluation is Finalized but never Canceled. Id - <rowId>
        # Setting product code other than DEE so that the evaluation is not captured and added to DEE database. This will lead to a missing evaluation scenario.
        * def appointment = karate.call('classpath:helpers/appointment/createAppointment.feature', { products: ['HHRA', 'PAD'] }).response
        * def evaluation = karate.call("classpath:helpers/eval/startEval.feature").response
        * def image1 = karate.readAsString('classpath:ancillary_services/features/dee/images/normalEval/image-1.txt')
        * def image2 = karate.readAsString('classpath:ancillary_services/features/dee/images/normalEval/image-2.txt')
        * set evaluation.answers =
            """
            [
                {
                    "AnswerId": 29554,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "1"
                },
                {
                    "AnswerId": 28377,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "John"
                },
                {
                    "AnswerId": 28378,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "Doe"
                },
                {
                    "AnswerId": 30974,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "M"
                },
                {
                    "AnswerId": 28383,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "TX"
                },
                {
                    "AnswerId": 30856,
                    "AnswerRowId": "6DBB912A-A078-4E7B-BE03-9DDB182628E4",
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(image1)"
                },
                {
                    "AnswerId": 30856,
                    "AnswerRowId": "FDBEC026-C6BE-4E5E-BE80-D6AC93E61F78",
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(image2)"
                },
                {
                    "AnswerId": 22034,
                    "AnsweredDateTime": "#(dateStamp)",
                    "AnswerValue": "#(dateStamp)"
                },
                {
                    "AnswerId": 33445,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(timestamp)"
                },
                {
                    "AnswerId": 21989,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.signature)"
                },
                {
                    "AnswerId": 28386,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.firstName) #(providerDetails.lastName)"
                },
                {
                    "AnswerId": 28387,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.nationalProviderIdentifier)"
                },
                {
                    "AnswerId": 22019,
                    "AnsweredDateTime": "#(timestamp)",
                    "AnswerValue": "#(providerDetails.degree)"
                }
            ]
            """

        * karate.call("classpath:helpers/eval/saveEval.feature")
        * karate.call("classpath:helpers/eval/stopEval.feature")
        * karate.call("classpath:helpers/eval/finalizeEval.feature")
        
        # Validate that no entry was made into the DEE table since the finalized event did not contain DEE product code
        * def evalResult = DeeDb().getExamId(evaluation.evaluationId, 3, 500)[0]
        * match evalResult == "#null"
        
        # Publish the cdi event to the cdi_events topic as the events raised by cdi service have CKD instead of DEE
        * string cdiEventName = "cdi_events"
        * string cdiEventKey = evaluation.evaluationId + "_" + monthDayYearCdi
        * def eventId = DataGen().uuid()
        * string cdiEventHeader = { 'Type' : "CDIPassedEvent"}
        # Including DEE in product code so that PM processes the event as the one published by cdi has PAD instead of DEE
        * def cdiEventValue = 
        """
            {
                "RequestId":"#(eventId)",
                "EvaluationId": "#(evaluation.evaluationId)",
                "DateTime":"#(cdiDateTime)",
                "Username":"karateTestUser",
                "ApplicationId":"manual",
                "Reason":"reschedule",
                "Products":[
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"HHRA"
                    },
                    {
                        "EvaluationId":"#(evaluation.evaluationId)",
                        "ProductCode":"DEE"
                    }
                ]
            }
        """
        * string cdiEventValueStr = cdiEventValue
        * KafkaProducerHelper.send(cdiEventName, cdiEventKey, cdiEventHeader, cdiEventValueStr)
        
        # Validate that there is no entry in the ProviderPay table
        * def providerPay = DeeDb().getProviderPayResultsWithEvalId(evaluation.evaluationId)[0]
        * match providerPay == "#null"

        # Validate that the Kafka event - ProviderPayRequestSent - was not raised
        * json event = JSON.parse(KafkaConsumerHelper.getMessageByTopicAndKeyAndHeader("dee_status", evaluation.evaluationId + '', "ProviderPayRequestSent", 10, 5000))
        * match event == {} 
        
        # Validate that the Kafka event - ProviderPayableEventReceived - was not raised
        * json payableEvent = JSON.parse(KafkaConsumerHelper.getKafkaMessageByTopicAndKeyAndHeader("dee_status", evaluation.evaluationId + '', "ProviderPayableEventReceived", 10, 5000))   
        * match payableEvent == {} 

        ## Additional checks on error queue count increasing to be added
        ## Additional checks on New Relic dashboard updates to be added
